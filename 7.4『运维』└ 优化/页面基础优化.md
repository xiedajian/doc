# 页面基础优化

- **引入位置**: css 文件`<head>`中引入， js 文件`<body>`底部引入；
	- 影响首屏的，优先级很高的 js 也可以头部引入，甚至内联； 
- **减少请求** (http 1.0 - 1.1)，合并请求，正确设置 http 缓存；
- **减少文件体积**: 
	- **删除多余代码**:
		- tree-shaking
		- UglifyJs
		- code-spliting 
	- **混淆 / 压缩代码**，开启 gzip 压缩；
	- **多份编译文件按条件引入**:
		- 针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件；
		- 可以利用`<script type="module"> / <script type="module">`进行条件引入用
	- **动态 polyfill**，只针对不支持的浏览器引入 polyfill；
- **图片优化**:
	- 根据业务场景，与UI探讨选择 **合适质量，合适尺寸**；
	- 根据需求和平台，选择 **合适格式**，例如非透明时可用 jpg；非苹果端，使用 webp；
	- 小图片合成 **雪碧图**，低于 5K 的图片可以转换成 **base64** 内嵌；
	- 合适场景下，使用 **iconfont** 或者 **svg**；
- **使用缓存**:
	- **浏览器缓存**: 通过设置请求的过期时间，合理运用浏览器缓存；
	- **CDN缓存**: 静态文件合理使用 CDN 缓存技术；
		- HTML 放于自己的服务器上；
		- 打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；
		- 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；
	- **服务器缓存**: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上；
	- **数据缓存**: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；

# 首屏渲染优化

- **css / js 分割**，使首屏依赖的文件体积最小，内联首屏关键 css / js；
- 非关键性的文件尽可能的 **异步加载和懒加载**，避免阻塞首页渲染；
- 使用`dns-prefetch / preconnect / prefetch / preload`等浏览器提供的资源提示，加快文件传输；
- 谨慎控制好 **Web字体**，一个大字体包足够让你功亏一篑；
	- 控制字体包的加载时机；
	- 如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积；  
- 合理利用 Localstorage / server-worker 等存储方式进行 **数据与资源缓存**；
- **分清轻重缓急**:
	- 重要的元素优先渲染；
	- 视窗内的元素优先渲染；
- **服务端渲染(SSR)**:
	- 减少首屏需要的数据量，剔除冗余数据和请求；
	- 控制好缓存，对数据/页面进行合理的缓存；
	- 页面的请求使用流的形式进行传递；
- **优化用户感知**:
	- 利用一些动画 **过渡效果**，能有效减少用户对卡顿的感知；
	- 尽可能利用 **骨架屏(Placeholder) / Loading** 等减少用户对白屏的感知；
	- 动画帧数尽量保证在 **30帧** 以上，低帧数、卡顿的动画宁愿不要；
	- js 执行时间避免超过 **100ms**，超过的话就需要做:
		- 寻找可 缓存 的点； 
		- 任务的 分割异步 或 web worker 执行；